use std::any::Any;
use std::ops::Deref;
use std::slice;
use std::str;
use std::sync::atomic::{AtomicU32, Ordering};
use serde::{Serialize, Deserialize};

use postcard::{from_bytes, to_allocvec};

/// This is a Boot Electron. Call it as Boot electron to see what happens!
/// THis is CSL generated
#[no_mangle]
#[cfg(feature = "decorate_string_atom1")]
pub extern "C" fn boot_enjoy_decorating(_: i32, _: i32) -> i32 {

	enjoy_decorating();

	// Boot Electron returning `0` indicates that Everything is alright
	return 0;
}


/// Let's enjoy doing some decorations
/// THis is App-dev defined
#[cfg(feature = "decorate_string_atom1")]
fn enjoy_decorating() {
	let input = String::from("Tarun likes doing this");
	let decorated = decorate_string_sender_stub(input);
	csl::print(decorated.as_str());
}

#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
struct DecorateStringArgs {
	input: String
}

#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
struct DecorateStringRetval {
	output: String
}

/// Stub function to invoke `decorate_string`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[cfg(feature = "decorate_string_atom1")]
fn decorate_string_sender_stub(input: String) -> String {

	//TODO: use tuple instead of structs
	let handle1 = csl::spawn(
		"decorate_string_receiver_stub",
		Some(DecorateStringArgs { input })
	);

	let output = csl::join::<DecorateStringRetval>(handle1).unwrap();

	return output.output;
}


/// Stub function to invoke `decorate_string`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[no_mangle]
#[cfg(feature = "decorate_string_atom2")]
pub extern "C" fn decorate_string_receiver_stub(index: i32, len: i32) -> i32 {
	let args = csl::get_args::<DecorateStringArgs>(index as u32, len as usize);

	let output = decorate_string(args.input);

	let ret_val_vec = to_allocvec(&DecorateStringRetval { output }).unwrap();
	let ret_index = csl::put_ret_val(ret_val_vec);

	ret_index as i32
}

/// A developer-defined function that takes a String and "decorates" it
#[cfg(feature = "decorate_string_atom2")]
fn decorate_string(input: String) -> String {
	format!("( ͡° ͜ʖ ͡°)_/¯ {input} ( ͡° ͜ʖ ͡°)_/¯")
}
