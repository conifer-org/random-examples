use std::any::Any;
use std::ops::Deref;
use std::slice;
use std::str;
use std::sync::atomic::{AtomicU32, Ordering};
use serde::{Serialize, Deserialize};

use postcard::{from_bytes, to_allocvec};

/// Let's enjoy doing some addions
/// THis is App-dev defined
#[csl::atom(name = "multi_app_thread")]
#[csl::boot_electron]
fn enjoy_adding() {
	let thread_nos = 5;
	for i in 0..thread_nos {
		// Stub is placed instead of real function by CSL
		let added = add_return_str_sender_stub(i, i + 1);
		csl::print(&added.1);
		//TODO: we need to spawn and join. Function name must change
		//csl::spawn::<()>("print_random_stuff", None);
	}
}

/// Stub function to invoke `add_return_str`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[csl::atom(name = "multi_app_thread")]
fn add_return_str_sender_stub(a: u32, b: u32) -> (u32, String) {

	//TODO: use tuple instead of structs
	let handle1 = csl::spawn(
		"add_return_str_receiver_stub",
		Some((a, b))
	);

	let output = csl::join::<(u32, String)>(handle1).unwrap();

	return output;
}

/// Stub function to invoke `add_return_str`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[no_mangle]
#[csl::atom(name = "multi_app_thread")]
pub extern "C" fn add_return_str_receiver_stub(index: i32, len: i32) -> i32 {
	let args = csl::get_args::<(u32, u32)>(index as u32, len as usize);

	let output = add_return_str(args.0, args.1);

	let ret_val_vec = to_allocvec(&output).unwrap();
	let ret_index = csl::put_ret_val(ret_val_vec);

	ret_index as i32
}

/// A developer-defined function that takes a String and "addes" it
#[csl::atom(name = "multi_app_thread")]
fn add_return_str(a: u32, b: u32) -> (u32, String) {
	let sum = a + b;
	(sum, format!("( ͡° ͜ʖ ͡°)_/¯ {a} + {b} = {}", a + b))
}
