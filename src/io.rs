//! This is `atom1`

use std::ops::Deref;
use std::slice;
use std::str;
use std::sync::atomic::{AtomicU32, Ordering};
use serde::{Serialize, Deserialize};

use postcard::{from_bytes, to_allocvec};

static HELLO: &'static str = "Hello, World!";


/// Prints a customized line to conterm
/// > This function is created by app developer
fn print_to_conterm(string_from_host: &str) {
    let mut id;

    //// The call to CSL/CSF that is statically/dynamically lined. One is chosen based on features enabled
    {
        #[cfg(feature = "csl_static")]
        { id = csl::get_id_static(); }

        #[cfg(feature = "csl_dynamic")]
        // This WILL WORK. The function call will succeed due to no memory linking requirement
        { id = csl::get_id_dynamic(); }

        #[cfg(feature = "csf_static__csl_static")]
        { id = csf::get_id(); }

        #[cfg(feature = "csf_dynamic__csl_static")]
        { id = csf::get_id(); }
    }

    let (csf, csl) = match id {
        60 => ("NA", "static"),
        65 => ("NA", "dynamic"),
        15 => ("static", "static"),
        20 => ("dynamic", "static"),
        _ => ("NA", "NA")
    };

    let out_str = format!("Message from app:: {}\nStatus: CSF({}), CSL({})",
                          string_from_host, csf, csl);

    // Stub is placed instead of real function by CSL
    csl::print(&out_str);
}


/// Stub function to invoke `print_to_conterm`
/// It's invoked from the outside **without** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn print_to_conterm_no_args_stub(_: i32, _: i32) -> i32 {
    print_to_conterm("I am Conifer!");
    return 0;
}

/// Stub function to invoke `print_to_conterm`
/// It's invoked from the outside **with** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn print_to_conterm_args_stub(index: i32, len: i32) -> i32 {

    let string_from_host; //this was initially an argument to this function, but CSL makes it
    // into local variable at top of the function

    // Stub is placed instead of real function by CSL
    #[cfg(feature = "csl_static")]
    //the following function call with compressed parameters should be generated by Hydro
    #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
    struct PrintToContermArgs {
        string_from_host: String
    }
    let args: PrintToContermArgs = csl::get_args(index as usize, len as usize);
    string_from_host = args.string_from_host;

    print_to_conterm(&string_from_host);
    return 0;
}


/// The function spawns `thread_nos` number of threads running the `print_to_conterm` function
/// > This function is created by app developer
fn test_spawn(thread_nos: u8) {
    for _ in 0..thread_nos {
        // Stub is placed instead of real function by CSL
        csl::spawn("print_to_conterm_no_args_stub", None);
    }
}

/// Stub function to invoke `test_spawn`
/// It's invoked from the outside **with** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn test_spawn_args_stub(index: i32, len: i32) -> i32 {

    let thread_nos; //this was initially an argument to this function, but Hydro makes it
    // into local variable at top of the function

    // Stub is placed instead of real function by CSL
    #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
    struct TestSpawnArgs {
        thread_nos: u8,
    }
    let args: TestSpawnArgs = csl::get_args(index as usize, len as usize);
    thread_nos = args.thread_nos;

    test_spawn(thread_nos);
    return 0;
}

/// Stub function to invoke `test_spawn`
/// It's invoked from the outside **without** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn test_spawn_no_args_stub(_: i32, _: i32) -> i32 {
    static FIXED: u8 = 4;
    test_spawn(FIXED);
    return 0;
}

/// Stub function to run some test code for Multi-MoleculeThreads TEMPORARY
#[no_mangle]
pub extern "C" fn multi_moleculethreads_test_no_args_stub(_: i32,_: i32) -> i32 {
    let handle1 = csl::spawn("print_numbers_loop_no_args_stub", None);
    csl::print(&format!("Started Thread 1: {}", handle1));
    let handle2 = csl::spawn("print_numbers_loop_no_args_stub", None);
    csl::print(&format!("Started Thread 2: {}", handle2));
    return 0;
}

static THE_NUM: AtomicU32 = AtomicU32::new(0);
static LOOP_ID: AtomicU32 = AtomicU32::new(0);

/// Stub function to run some test code for Print numbers in a loop TEMPORARY
#[no_mangle]
pub extern "C" fn print_numbers_loop_no_args_stub(_: i32, _: i32) -> i32 {
    let loop_id = LOOP_ID.fetch_add(1, Ordering::SeqCst);
    for _ in 0..50 {
        csl::print(&format!("Loop ID {} num: {}", loop_id, THE_NUM.fetch_add(1, Ordering::SeqCst)));
    }
    return 0;
}
