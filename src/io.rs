//! This is `atom1`

use std::any::Any;
use std::ops::Deref;
use std::slice;
use std::str;
use std::sync::atomic::{AtomicU32, Ordering};
use serde::{Serialize, Deserialize};

use postcard::{from_bytes, to_allocvec};

static HELLO: &'static str = "Hello, World!";


/// Prints a customized line to conterm
/// > This function is created by app developer
fn print_to_conterm(string_from_host: &str) {
    let mut id;

    //// The call to CSL/CSF that is statically/dynamically lined. One is chosen based on features enabled
    {
        #[cfg(feature = "csl_static")]
        { id = csl::get_id_static(); }

        #[cfg(feature = "csl_dynamic")]
        // This WILL WORK. The function call will succeed due to no memory linking requirement
        { id = csl::get_id_dynamic(); }

        #[cfg(feature = "csf_static__csl_static")]
        { id = csf::get_id(); }

        #[cfg(feature = "csf_dynamic__csl_static")]
        { id = csf::get_id(); }
    }

    let (csf, csl) = match id {
        60 => ("NA", "static"),
        65 => ("NA", "dynamic"),
        15 => ("static", "static"),
        20 => ("dynamic", "static"),
        _ => ("NA", "NA")
    };

    let out_str = format!("Message from app:: {}\nStatus: CSF({}), CSL({})",
                          string_from_host, csf, csl);

    // Stub is placed instead of real function by CSL
    csl::print(&out_str);
}


/// Stub function to invoke `print_to_conterm`
/// It's invoked from the outside **without** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn print_to_conterm_no_args_stub(_: i32, _: i32) -> i32 {
    print_to_conterm("I am Conifer!");
    return 0;
}

/// Stub function to invoke `print_to_conterm`
/// It's invoked from the outside **with** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn print_to_conterm_args_stub(index: i32, len: i32) -> i32 {

    let string_from_host; //this was initially an argument to this function, but CSL makes it
    // into local variable at top of the function

    // Stub is placed instead of real function by CSL
    #[cfg(feature = "csl_static")]
    //the following function call with compressed parameters should be generated by Hydro
    #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
    struct PrintToContermArgs {
        string_from_host: String
    }
    let args: PrintToContermArgs = csl::get_args(index as u32, len as usize);
    string_from_host = args.string_from_host;

    print_to_conterm(&string_from_host);
    return 0;
}


/// The function spawns `thread_nos` number of threads running the `print_to_conterm` function
/// > This function is created by app developer
fn test_spawn(thread_nos: u8) {
    for _ in 0..thread_nos {
        // Stub is placed instead of real function by CSL
        csl::spawn::<()>("print_to_conterm_no_args_stub", None, None);
    }
}

/// Stub function to invoke `test_spawn`
/// It's invoked from the outside **with** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn test_spawn_args_stub(index: i32, len: i32) -> i32 {

    let thread_nos; //this was initially an argument to this function, but Hydro makes it
    // into local variable at top of the function

    // Stub is placed instead of real function by CSL
    #[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
    struct TestSpawnArgs {
        thread_nos: u8,
    }
    let args: TestSpawnArgs = csl::get_args(index as u32, len as usize);
    thread_nos = args.thread_nos;

    test_spawn(thread_nos);
    return 0;
}

/// Stub function to invoke `test_spawn`
/// It's invoked from the outside **without** arguments
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn test_spawn_no_args_stub(_: i32, _: i32) -> i32 {
    static FIXED: u8 = 4;
    test_spawn(FIXED);
    return 0;
}

/// Stub function to run some test code for Multi-MoleculeThreads TEMPORARY
#[no_mangle]
pub extern "C" fn multi_moleculethreads_test_no_args_stub(_: i32,_: i32) -> i32 {
    let handle1 = csl::spawn::<()>("print_numbers_loop_no_args_stub", None, None);
    csl::print(&format!("Started Thread 1: {}", handle1));
    let handle2 = csl::spawn::<()>("print_numbers_loop_no_args_stub", None, None);
    csl::print(&format!("Started Thread 2: {}", handle2));
    return 0;
}

static THE_NUM: AtomicU32 = AtomicU32::new(0);
static LOOP_ID: AtomicU32 = AtomicU32::new(0);

/// Stub function to run some test code for Print numbers in a loop TEMPORARY
#[no_mangle]
pub extern "C" fn print_numbers_loop_no_args_stub(_: i32, _: i32) -> i32 {
    let loop_id = LOOP_ID.fetch_add(1, Ordering::SeqCst);
    for _ in 0..50 {
        csl::print(&format!("Loop ID {} num: {}", loop_id, THE_NUM.fetch_add(1, Ordering::SeqCst)));
    }
    return 0;
}

//-------------------------------------------------------

/// This is a Boot Electron. Call it as Boot electron to see what happens!
/// THis is CSL generated
#[no_mangle]
pub extern "C" fn boot_enjoy_decorating(_: i32, _: i32) -> i32 {

    enjoy_decorating();

    // Boot Electron returning `0` indicates that Everything is alright
    return 0;
}


/// Let's enjoy doing some decorations
/// THis is App-dev defined
fn enjoy_decorating() {
    let input = String::from("Tarun likes doing this");
    let decorated = decorate_string_sender_stub(input);
    csl::print(decorated.as_str());
}

#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
struct DecorateStringArgs {
    input: String
}

#[derive(Serialize, Deserialize, Debug, Eq, PartialEq)]
struct DecorateStringRetval {
    output: String
}

/// Stub function to invoke `decorate_string`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
fn decorate_string_sender_stub(input: String) -> String {

    //TODO: use tuple instead of structs
    let handle1 = csl::spawn(
        "decorate_string_receiver_stub",
        None,
        Some(DecorateStringArgs { input })
    );

    let output = csl::join::<DecorateStringRetval>(handle1).unwrap();

    return output.output;
}


/// Stub function to invoke `decorate_string`
/// It's invoked from the outside with arguments and returns a return value
/// > This function is autogenerated by CSL
#[no_mangle]
pub extern "C" fn decorate_string_receiver_stub(index: i32, len: i32) -> i32 {
    let args = csl::get_args::<DecorateStringArgs>(index as u32, len as usize);

    let output = decorate_string(args.input);

    let ret_val_vec = to_allocvec(&DecorateStringRetval { output }).unwrap();
    let ret_index = csl::put_ret_val(ret_val_vec);

    ret_index as i32
}

/// A developer-defined function that takes a String and "decorates" it
fn decorate_string(input: String) -> String {
    format!("( ͡° ͜ʖ ͡°)_/¯ {input} ( ͡° ͜ʖ ͡°)_/¯")
}
